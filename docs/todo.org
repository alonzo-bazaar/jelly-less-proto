* Basi
rivedi un po' di sicp e crafting interpreters per farti una mezza idea su come fare per ripulire il codice e le idee che hai creato

* Package
certi package VANNO RINOMINATI CAZZO
 - ~lang~ mettilo tipo ~jelly.lang~, e da lì puoi anche togliere nomi come ~LispExpression~ o ~LispSymbol~, avrai qualcosa di molto più chiaro come ~jelly.lang.Expression~ e ~jelly.lang.Symbol~
   (oppure ~org.jelly.lang~, per stile, o per fare il pirla)
   
* Parser
** Characters
invece di limitarci a caratteri e basta potrebbe aiutare ristruttrare certe parti del codice con un'architettura più "a scanner" che permetta sia un ~nextChar~ che un ~nextLine~

questo sarebbe da farsi facendo in modo che lo "scanner" in questione non diventi un ammassone di merda

** Tokens
end of file deve essere un token secondo me

** Iteration
è probabile che un ~getLine~ e ~tokenizeLine~ porterebbe a del codice più gestibile (senza ~prefixIterator~)

ai fini di usare il ~hasNext()~ più come check di "posso prendere?" sarebbe utile costruire internamente la rappresentazione, mandarla, e continuare
questo permetterebbe, vale a dire, il poter mandare stringhe di codice multiline nel repl (non stringhe multiline, proprio codice multline)

*** ~hasNext~ con lista di valori precalcolati
costruire i valori sul momento porta a problemi per quanto riguarda il "ok, i caratteri/token/... in arrivo non mi permettono di costruire un token/espressione/... completi"
sarebbe da fare un
 - esaurisci i dati in input, costruendo tutti gli enti che puoi
   - per ~hasNext~ vedi se la lista e vuota
   - per ~next~ consuma l'elemento più vecchio della lista

poi per quando vuoi continuare si farà solo che al capo dei capi (vale a dire l'iteratore di caratteri, o righe, o cazzo capita) verrà data nuova roba, e da lì potrai continuare

questo sistemerebbe anche la semantica dell' ~hasNext~ di expressionIterator, la cosa si può ovviamente generalizzare con vettori/liste di oggetti "prefetched" che vengono costruiti, consumati/mandati, contorollati in modo tale da permettere casi in cui i dati in arrivo costituiscano solo una rappresentazione parziale dell'ente che stai mandando

sarebbe da vedere se sia o meno il caso di rievocare la bestia di satana che era fare il "send token, send tree, etc..."
** Intermediate Form
*** Abstract Synthax tree
 - una classe a parte per l'abstract synthax tree
 - magari anche una "sealed interface" che ha sia token (con un tipo) che cons
 - vedi poi se conviene ancora avere cons come struttura per l'ast
   (tanto non useresti i cons normali, visto che l'ast avrà anche informazioni per error reporting e sarà palesemente codice senza troppo di dati)
 - come/se mantenere il mantra "code is data" con una cosa del genere?
** Repl Specifics
multiline and dandelion wine

* Evaluator
** Type System
sarebbe gradito se si potesse fare un ~LispExpression.type~ da qualche parte
le due/tre idee al momento sono
 - non avere un type system
 - avere un type system e
   - avere tipi ~LispType~ per builtin e struct
   - avere tipi a parte(di java) per i builtin, e usare un ~LispType~ a parte per gli struct

il tipo di un'espressione sarebbe immutabile e abbastanza ~final~ anche per le classi (tipo un ~public static final LispType type~)
vedere poi se aiuta con boh, leggibilità&Co.

classe cast?

** Builtin Functions
*** Lambda
mettere nuove funzioni builtin porterà a probelmi GROSSI per quanto riguarda la pulizia, più di altro, della loro chiamata

al momento è un simile switchone orrendo sul nome che yanderedev si bagna a letto

** Error Seporting
 - mettere informazioni di debug nel synthax tree e forse anche nei token
 - (tanto probabile il synthax tree lo faccio con un composite e le leaf sono token)
